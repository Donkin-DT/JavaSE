###### 第六章 面向对象（下）

```java
1、static关键字😀
2、final关键字
3、单例设计模式😀【面试题】
4、初始化块  【面试题】
5、抽象类😀【应用】
6、接口😀【应用】
7、内部类
8、枚举
9、注解
10、异常
```

###### static关键字😀

```java
理解：
	static 看作一种修饰符，可以用于修饰类的成员（属性、方法、内部类、初始化块），但不能修饰构造器和局部变量
	使用 static 修饰的成员，称为静态成员
	用 static 修饰的属性，称为静态属性
	用 static 修饰的方法，称为静态方法
	
	没有使用 static 修饰的成员，称为普通成员或实例成员
	没有使用 static 修饰的属性，称为普通属性或实例变量
	没有使用 static 修饰的方法，称为普通方法或实例方法

特点：
	1、静态成员随着类的加载而加载
	2、静态成员都是存储方法区（静态域）
	3、静态成员整个内存中只有一份
	4、静态成员都是和对象无关的成员，所以可以直接通过类名调用
	5、静态成员（除了静态属性），里面都是可以直接调用其他静态成员，不能直接调用普通成员
```
######单例设计模式😀
```java
什么时候使用单例模式：
	当一个项目中 要求某类只有一个对象时！

应用场景：
	1、项目中只想多次调用该对象的方法时，为了提高效率
	2、如果创建多个对象，会导致逻辑错误时

创建步骤：
	1、构造器私有化
	2、本类内部创建对象
	3、提供 public static 方法，暴露该对象

分类：😀
	饿汉式：
		public class SingleTon {
			//步骤一：封锁构造方法：
			private SingleTon() {
				super();
			}
			
			//步骤二：创建一个引用：
			private static SingleTon st = new SingleTon();
	
			//步骤三：用public static 暴露单例：
			public static SingleTon getSingleTon() {
				return st;
			}
		}
	
	懒汉式：
		public class SingleTon {
			//步骤一：封锁构造方法：
			private SingleTon() {
				super();
			}
	
			//步骤二：创建一个引用：
			private static SingleTon st;
	
			//步骤三：用public static 暴露单例：
			public static SingleTon getSingleTon() {
            	if(st == null) {
					synchronized (Simgle.class) {
						if (st == null) {
							st = new SingleTon();
						}
					}
				}
				return st;
			}
		}
		
	差别：
		1、创建对象的时机不同！
		2、应用场合不同
		如果仅仅考虑效率问题，可以使用懒汉式
 		如果考虑线程安全问题，可以使用饿汉式
 	经典案例：Runtime 类就使用了饿汉式单例设计模式
```
###### final关键字

```java
理解：
	final 关键字属于一种修饰符，可以用于修饰类、属性、方法、局部变量

特点：😀
	 1、修饰类
 		如果用 final 修饰类，则该类变成了“太监类”，不能被继承
 		代表类：String、Integer 等
 	2、修饰方法
 		如果用 final 修饰方法，则该方法不能被重写，但可以被继承
 	3、修饰属性和局部变量
	  	①如果修饰变量（属性和局部），该变量就变成了常量，一旦赋值，将不能更改！
	  	②修饰属性，需要注意以下事项：
	  		a、命名时最好遵循见名知义,且纯大写，提高代码的阅读性！
	 		b、一般来讲 static 和 final 往往一起搭配修饰常量属性
	  			两个修饰符的意思不冲突
	  			调用比较方便
	  			jvm 对使用这两个修饰符搭配的属性，内部进行了优化
	  		c、常量属性在声明时或构造器时必须初始化
	  	③基本类型的值，一旦更改，则就是更改值，不允许！
	  		引用类型的对象，如果更改属性值是允许的，但不能更改地址号！
```

###### 初始化块😀

```java
理解：
	初始化块又称为代码块。属于类中的第四大成员。本质上同“方法”，只是没有返回，没有参数，没有方法名，只有方法体，而且也不是通过对象或类显式调用，而是在加载类或创建对象时隐式调用的。
	
语法:
	【修饰符】{
		方法体
	}
	注意：
		①修饰符只能是 static 。
			初始化块根据有无 static 修饰符分为两类：
				静态初始化块（有 static 修饰）
				普通初始化块（没有 static 修饰）
		②方法体中可以是0条或任意多条逻辑语句

好处:
	1、用于初始化信息的
	2、当多个构造器中有重复的代码时，可以将这些语句抽取到初始化块中，提高代码重用性！
		a.静态初始化块的调用时机：加载类
		b.普通初始化块的调用时机：创建对象
		c.静态初始化块只会调用一次，随着类的加载而加载，（类只加载一次）
		d.普通初始化块可以调用多次，随着对象的创建而加载
	3、一个类中可以有多个静态初始化块和多个普通初始化块
	   	a.静态初始化块的执行要早于普通初始化块
	    b.同一个类型的初始化块的执行顺序取决于定义的先后顺序！
	4、一个类中如果有：静态初始化块、普通初始化块、普通属性初始化、静态属性初始化、构造器。执行顺序：
		静态初始化块|静态属性初始化>普通初始化块|普通属性初始化>构造器
	5、有父子类，执行顺序：
		爷爷类的静态初始化块|静态属性初始化>
		父类静态初始化块|静态属性初始化>
		子类静态初始化块|静态属性初始化>
		爷爷类普通初始化块|普通属性初始化>构造器>
		父类普通初始化块|普通属性初始化>构造器>
		子类普通初始化块|普通属性初始化>构造器
	6、静态初始化块中遵循静态成员的特点，只能直接访问静态成员！
```

###### 抽象类😀


```java
概念：
	如果某类中有不好描述的行为，则往往将该类设计成抽象类，其中里面不好描述的行为设计成抽象方法
特点：
	①父类
	②里面有不好描述的行为（抽象方法）
	③该类不需要创建对象
	
语法：
  	 abstract class Person{}

特点:
	①抽象类中可以有普通成员，也可以有抽象方法
  	②抽象类有构造器（任何类都有构造器），
  		目的：为了子类调用时，初始化父类信息
	③抽象类不能创建本类对象
  	④抽象类不能使用 final 修饰，
  		原因：和抽象类的意义冲突
  	⑤抽象类的扩展
  		子类继承抽象类时，如果子类是具体的实现类，要求必须实现抽象类中的抽象方法，如果子类是抽象类，则不用实现抽象类的抽象方法
```
###### 抽象方法😀

```java
语法：
	public abstract int show(int a,int b);

特点：
	1、没有方法体，只有方法签名
	2、抽象方法不能被 private 、 static 或 final 修饰，因为违背了实现的意义
	3、抽象方法只能出现在抽象类或接口中，不能出现在具体的实现类中
```
###### abstract关键字😀

```java
理解：
	abstract 属于一种修饰符，用于修饰类或方法
	使用 abstract 修饰类，称为抽象类
	使用 abstract 修饰方法，称为抽象方法
```
######接口😀

```java
理解:
	接口：里面全部都是抽象方法
	抽象类：有抽象方法 + 普通方法  半成品
	实现类：只能有普通方法  成品
	
案例：
	武当派：
	张三丰 ：接口
	宋远桥：抽象类
	宋青书：实现类
	接口——>抽象类——>实现类
	
好处：
	1、接口避免了单继承的局限性
	2、接口的实现更加灵活，实现类和接口之间不再是 is-a 的关系，而是 like-a 的关系
	3、接口的实现提高了类的解耦性，降低了依赖性
	
定义特点：
	1、接口使用 interface 关键字定义
  	2、接口修饰符只能是 public 或默认
  	3、接口中只能是抽象方法和常量（ jdk8 之后）
  		常量的修饰符只能是 public static final
  		抽象方法的修饰符只能是 public abstract
  		修饰符可选，写不写都是上述的修饰符！
	4、接口中没有构造器
	5、接口不能创建本身的对象！
	
使用特点：
	1、使用 implement s实现接口，可以实现多个，中间用逗号隔开
		语法：
			class A implements 接口1，接口2{}
		注意：
			如果是抽象类实现接口，则不用实现里面的抽象方法
  			如果是普通类实现接口，则必须实现里面全部的抽象方法
	2、一个类可以既继承其他类，又实现接口
		语法：
  			class A extends 类B implements 接口1，接口2{}
	3、接口也可以继承其他接口，而且是多继承的！
		语法：
  			interface A extends 接口1，接口2{}

与抽象类对比：
	1.定义关键字不同
		抽象类：abstract class
		接口：interface
	2.有无构造器
		抽象类：有
		接口：无
	3.能否创建本身对象
		抽象类：不能
		接口：不能
	4.里面能否有普通的成员
		抽象类：可以有
		接口：不能有
	5.里面的属性的修饰符
		抽象类：无要求
		接口：只能是 public static final （可以省略）
	6.里面的抽象方法的修饰符
		抽象类：无要求，当然不能是 private 、 static 、 final 修饰，其他可以
		接口：只能是 public abstract （可以省略）
	7.继承关系
		抽象类：单继承
		接口： 多继承多实现
		
案例:
	interface A{
		void show1（）；
		void  show2();
		...
	}

	//适配器类
	abstract class absClass implements A{
		void  show2(){}
		...
	}

	class Sub extends absClass{
		void show1（）{}
	}
```
###### 内部类😀

```java
理解:
	一个类体中又完整的嵌套了另一个类结构，被嵌套在里面的类，称为内部类
	外面的类，称为外部类。
	其他的类，称为外部其他类。
	class Outer{
		class Inner{}
		public void method(){
			class Inner2{ }
		}
	}

好处:
	可直接访问外部类的所有成员，包含私有的

分类：(按位置不同)
	定义在成员位置上：
		成员内部类（没有使用static修饰）
		静态内部类（使用static修饰）
	定义在局部位置上：
		局部内部类（有类名）
		匿名内部类（没有类名） 
```
###### 枚举😀

```java
理解:
	jdk5.0 新特性，枚举本质上就是一个类，它里面只有一组限定的对象

创建：
	传统方式：
		单例类：只有一个对象
			实现思路：
				1、构造器私有化
				2、本类内部创建一个对象
				3、本类内部提供一个公共的静态的方法对外暴露对象
		枚举类：只有一组对象
			实现思路：
				1、构造器私有化
				2、本类内部创建一组公共的静态的对象
	
	使用enum关键字定义枚举【掌握】
		特点：
  			1、使用 enum 关键字代替 class 关键字
  			2、对象（常量）的创建必须放在枚举类中的第一句
  				语法：
  				对象名(实参列表),对象名(实参列表);
  			3、如果是无参构造，则无参构造的定义和实参列表都可以省略
常见方法:
	toString:	public String toString()
		Enum 类已经重写过了，返回的是当前对象的常量名。自定义的枚举类可以继续重写该方法
	name:	public final String name()
		Enum 类中的 name 方法返回的是当前对象的常量名（同 toString ），但自定义的枚举类不可以继续重写该方法
	values:
		一个静态方法，用于返回指定的枚举类中的所有枚举常量
	valueOf:	public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name)
		一个静态方法，将一个有效的字符串转换成枚举对象

枚举类实现接口：
	特点：
		1.和普通类实现接口一样，只是允许枚举常量也有自己对抽象方法的特有实现！
  		2.enum 类不能再继承其他类，因为已经隐式的直接继承了 Enum 类
        
	语法：
		enum A implements 接口1，接口2{
            常量1(参数){
                //抽象方法的实现
 	 		},常量2(参数){
 	 			//抽象方法的实现
 			}
 	 			//类对抽象方法的实现
 	 		}
```
######  注解

```java
定义：
	用于修饰 java 中的数据（属性、方法、构造器、类等），相当于程序中的补充文字。不改变程序的逻辑，但可以被编译器或运行时解析，并做相应处理
	
内置的三种基本注解:【掌握】😀
	@Override：
		只能用于修饰方法，检测被修饰的方法是否为有效的重写，如果不是，则报编译错误！ 
  	@Deparecated:
  		用于表明被修饰的数据已经过时，不建议使用，为了新老版本的兼容，没有贸然的废弃，只是提醒！可以用于修饰：类或接口、属性、方法、构造、局部变量、包、参数
	@Suppresswarnings:
		用于抑制程序中的编译警告，可以用于修饰类或接口、属性、方法、构造、局部变量、参数

自定义注解:
	定义注解：
		1、定义注解的关键字	@interface
  		2、注解类体中的成员是：
  			参数类型 方法名();
	注意：
   		①参数类型只能是 八大基本类型、String、枚举类、Class 类型或上述类型的数组类型
   		②方法名遵循标识符的命名规则和规范，但建议使用 value 因为使用时，可以省略方法名
   		③可以在定义方法时，指定默认值，语法：参数类型 方法名() default 默认值;

使用：
	在被修饰的数据上方，添加注解即可。	
	语法：
		@注解类型(方法名=值)  
 
四种元注解【了解】
	Retention:
		用于指明被修饰的注解可以保留多长,RententionPolicy:SOURCE  CLASS  RUNTIME
	Target：
		用于指明被修饰的注解可以用于修饰哪些数据,ElementType:TYPE LOCAL_VARIABLE FIELD METHOD等
	Documented：
		能否在生成的帮助文档中显示
	Inherited：
		注解是否具备继承性
```
###### 异常😀

```java
体系图:😀
	Throwable
		Error:严重错误
		Exception：异常
			编译异常（受检异常):
				①IOException，②SQLException
			RuntimeException（运行异常):
				①NullPointerException，②ClassCaseException，③IndexOutOfBoundsException，④ArithmeticException，⑤Number Format Exception

常见异常：😀
	NullPointerException 
		空指针异常,当试图使用null对象的属性或方法时
	ArrayIndexOutOfBoundsException 
		数组下标越界异常,当试图使用数组的索引超过范围：0——length-1
	ClassCastException 
		类型转换异常,当试图将不是该类型的实例强转成该类型
	ArithmeticException 
		数学运算异常,除数为0时
	NumberFormatException 
		数字格式不正确,当试图将字符串转换成数值时，如果该字符串不是有效的数值格式异常处理的概念

异常处理：😀
	处理程序中发生的不正常现象，称为异常处理，java中的异常处理机制，属于抓抛模型！

异常处理分类：😀
    方式一：自己处理
    	try{
       	 	需要检测的代码块
    	}catch(异常类型 名){
        	处理的语句
    	}
    
    方式二：抛给他人处理
		语法：throws
	
	方式三：自己处理（抓）
		语法：
        	try{
            	//容易出现异常的代码
        	}catch(异常类型 e){
            	//处理异常的语句
       	 	}
        	[finally{
            	//最后一定要执行语句
        	}]
		执行顺序：😀
			①如果try块中出现了异常，则 try 块中下面的语句不再执行，直接判断 catch 块的异常类型是否匹配，
	  			如果匹配，则执行 catch 块的语句；
	  			如果不匹配，则执行默认的处理方式
	  			最后执行 finally 块
	   	 	②如果try块中没有出现异常，则继续执行 try 块中下面的语句，不再执行 catch 块。最后执行finally 块好处：
	1、拦截异常，让 try catch 块下面的语句可以正常执行
	2、提高用户的体验性
	3、让正常代码和容易出错的代码进行了有效的分离，从一定程度上讲，提高语义性和维护性！

注意事项：
	1、catch 块可以省略
	2、catch 块可以多个，要注意 catch 块中有父类的异常类型。要放在最后
	3、并不是 try 块中的语句越多越好，因为 try 块的语句过多，会影响效率！
	4、尽量使用多个 catch 块代替多个 try catch

抛出异常：
	语法：
		修饰符 返回类型 方法名(参数列表) throws 异常类型{
			//容易出现异常的代码
			int i=1/0;
		}
	注意：抛出的异常类型应该写方法容易出现的具体的异常类型或其父类类型
	
	执行机制：
		将方法中的异常抛给调用方，调用方可以有两种处理异常的方式，如果继续往上抛，则可以一直抛到 jvm，则 jvm 会采用默认的处理方式：打印错误堆栈日志
	特点：
		如果程序中出现了异常，而我们没有做任何处理，默认的处理方式：第二种（抛）
		子类重写父类方法时对抛出异常类型要求子类方法抛出的异常类型要么相同，要么为子类类型
		
自定义异常：
	【面试题1】生成异常对象的方式和区别
		1、系统自动生成
			只针对于 Throwable 和 Throwable 的子类！
		2、手动生成
			语法：
				throw new XXException (参数);
				可以针对于自定义类和系统定义的异常类
	
	【面试题2】throws 和 throw 对比
					理解						后面跟的东西				放的位置
		throw		手动生成异常对象的方式		    异常对象				方法体中
		throws		异常处理的第二种方式			异常类型				方法声明处
```