###### 第六章 面向对象（中）

```java
1.继承
2.对象数组
3.对象关联
4.多态
5.Object类
```

######继承😀


```java
理解:
	生活中的继承：
		子女继承父母的财产，继承父母的相貌、才华
	java 中的继承：
		有的类不需要定义属性和方法，则已经具备了另一个类的属性和方法，把这种现象称为继承。
		其中被继承的类称为 父类或超类或基类，继承其他类的类，称为子类或派生类

好处：
	1、提高代码的重用性
	2、提高代码的维护性和扩展性
	3、为后面学习多态打基础

语法：
	class 子类类名 extends 父类类名{}
	extends:扩展、派生

特点:😀
	1、子类到底继承了父类的什么？
		①子类继承了父类的所有的属性和方法，包含私有的，只是访问时需要先遵循访问权限的限定，有的不能直接使用，需要通过公共的 set 或 get 方法去使用
		②子类没有继承父类的构造器
	2、不能滥用继承！
		子类和父类之间必须满足is-a的关系！
		Cat extends Dog
		Cat 是一个狗吗？
	3、一个类可以直接继承多少个父类？
		Java 中支持的是单继承
	4、java 中所有的类都直接或间接继承了 Object 类（ Object 类是所有的类的祖宗类）
		ctrl + T：查看类的层级关系
	5、子类必须调用父类的构造器！

子类调用父类构造器:😀
	① 要求子类必须显式或隐式的调用父类的构造器
	②如果子类没有显式的调用父类的构造器，系统将默认调用父类的无参构造器
	③如果父类没有无参构造器,则要求子类必须显式的调用父类的有参构造器，通过 super 关键字
		语法：super(实参列表);
		注意：通过super调用构造器只能放在构造器的第一句
	④构造器的调用不限于直接父类,将一直往上追溯直到 Object 类
	⑤对于一个类的构造器来讲，里面调用父类的构造器可以有以下形式：
		形式1：没有任何调用本类或父类构造器的语句。隐式调用，但要求父类必须有无参构造器
		形式2：通过 super 显式调用父类的构造器
		形式3：通过 this 调用本类的构造器，然后被调用的构造器中再调用父类的构造器
```

######super关键字😀

```java
理解:
	super 关键字用于访问父类的成员，包含父类的属性、父类的方法、父类的构造器

语法：
	访问属性：
		super.属性名 = 值;
	访问方法：
   		super.方法名(实参列表);
	访问构造器：
   		super(实参列表);
   		注意：必须放在构造器中的第一句

好处：😀
	① 当父类中没有无参构造器，则子类必须通过 super 关键字显式调用父类的有参构造器！
 	② 当本类和父类的成员出现重名问题时，本类中默认访问的是本类的成员，如果想访问父类的成员，则必须通过 super 关键字调用
 	总结：
		当局部变量和当前类的成员变量重名时，默认访问局部变量，如果要访问成员变量，使用 this
		当成员变量和父类的成员重名时，默认访问本类的成员变量，如果要访问父类的成员，使用 super

特点：
	① super 的使用不限于直接父类，可以一直往上追溯，直到 Object 类
	②如果直接父类和间接父类都有同名的该成员，默认遵循就近原则
执行顺序：
    	super ：
   		直接父类的——>间接父类
	③ this (实参列表)和 super (实参列表)不可能同时出现！
```

######方法重写😀

```java
理解：
	子类对从父类继承来的方法，进行改造，程序执行时，默认执行的是子类本身的方法，这种现象称为方法重写（ Override ）
	
特点：😀
	①方法名必须相同
 	②参数列表必须相同
 	③返回类型相同， jdk5.0 之后子类方法的返回类型可以为父类返回类型的子类型
 	④修饰符相同或权限更大
```

###### 多态😀

```java
理解：
	多态：一种事物有多种表现形式。面向对象的最后一个特征，继承和封装都是为多态打基础！
	生活中的多态：
		打招呼：
		中国人：你好
		英国人：hello
		日本人：拷逆七娃
		韩国人：阿娘哈赛you
		泰国人：萨瓦迪卡

向上转型/多态:（引用类型之间的类型转换）
	本质：父类的引用指向了子类的对象

	语法：
		父类类型 引用名 = new 子类对象();

	特点：😀
		编译看左边，运行看右边
		可以调用父类类型中的所有成员，不能调用子类类型中特有成员；最终运行效果看子类的具体实现！

向下转型：😀
	语法：
		子类类型 引用名 = （子类类型） 父类引用;
	
	特点：
		①只能强转父类的引用，不能强转父类的对象
		②要求父类的引用必须指向的是当前目标类型的对象
		③可以调用子类类型中所有的成员
		注意：属性没有重写之说！属性的值看编译类型
		
多态应用：😀
	1、多态数组
		数组的元素类型允许是子类类型，相当于可以容纳更多的元素
	2、多态参数
		实参的类型允许是子类类型，相当于提高了代码的通用性和扩展性
```
###### Object类😀

```java
学习类的步骤：😀
	1、看包
	2、看类的说明（类是干什么）
	3、创建该类的对象（看构造器）
	4、看方法😀

	java.lang 包，不用手动导包，系统默认导入

说明：
	Object 类是所有类的根类，所有对象都具有该类的方法
	
构造器:
	new  Object();
	注意：很少用，因为不必须使用它，可以使用子类对象调用方法
```
###### equals方法😀

```java
== 与 equals 的对比:
	== 可以判断基本类型或引用类型，要求左右两边的类型一致或兼容，否则编译报错
		如果判断的是基本类型，判断的是值是否相等。 
			示例：100 == ‘d’ true	  1.0 == 1 true
  		如果判断的是引用类型，判断的是地址是否相等。
  			示例：person1 == person2    string1 == string2

equals 只能判断引用类型,可以判断任何引用类型，编译不会报错
  		Object 类的 equals ：默认判断的就是地址是否相等！往往子类需要重写 equals 方法，实现判断内容是否相等。比如：String、Integer 类等都重写了 equals 方法
 
重写equals方法:
	public boolean equals(Object obj){//this：person1  obj:person4
		//步骤1：两个对象的地址一样（提高效率）
			if(this==obj)
				return true;
		//步骤2：判断对象的类型
			if(!(obj instanceof Person)){//如果传入的obj不是Person类型，则直接返回
				return false;
			}
		//步骤3：对象的向下转型
			Person p = (Person) obj;//向下转型
		//步骤4：判断内容是否相等
			return this.name.equals(p.name)&&this.age==p.age;
    }
```

###### toString方法😀

```java
功能:
	返回对象的字符串形式。
	默认返回的是：全类名+@+哈希值的十六进制

语法：
	public String toString(){
		return getClass().getName()+"@"+Integer.toHexString(hashCode());
	}

	子类往往重写该方法

重写 toString 方法
	public String toString(){
		return 属性信息；
	}

好处：
	打印方法和拼接字符串时，会自动调用对象的 toString 方法，提高代码的简洁性！
```
###### hashCode方法

	功能
		返回对象的哈希值（以整数形式返回对象的一个特殊值），
		提高集合中查找元素相等的效率！
	特点
		对象的哈希值 约等于 对象的地址号
	推论
		如果哈希值不一样，则两个对象肯定不一样！
###### finalize方法

```java
自动垃圾回收机制

原理：
 	当应用已启动，实际上相当于开起了主线程 main 和垃圾回收器线程，垃圾回收器将默默检测是否有需要回收的对象，一旦有了，则需要回收该对象以释放空间供其他有用对象使用，该对象被回收时同时调用 finalize 方法

1、回收哪些对象？
 	答：无用对象（没有任何引用指向的对象）
 
2、回收的时机？
 	答：不确定的
 
3、如何加速垃圾回收器的回收？
 	答：唤醒垃圾回收器
 	System.gc();
 
4、finalize 方法什么时候被调用？
 	只要被回收，肯定被调用
```